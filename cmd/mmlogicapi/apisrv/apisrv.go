/*
package apisrv provides an implementation of the gRPC server defined in ../../../api/protobuf-spec/mmlogic.proto.

Copyright 2018 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    https://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

package apisrv

import (
	"context"
	"errors"
	"fmt"
	"net"

	mmlogic "github.com/GoogleCloudPlatform/open-match/cmd/mmlogicapi/proto"
	"github.com/GoogleCloudPlatform/open-match/internal/metrics"
	"github.com/GoogleCloudPlatform/open-match/internal/statestorage/redis/ignorelist"
	log "github.com/sirupsen/logrus"
	"go.opencensus.io/stats"
	"go.opencensus.io/tag"

	"github.com/gomodule/redigo/redis"
	"github.com/spf13/viper"

	"go.opencensus.io/plugin/ocgrpc"
	"google.golang.org/grpc"
)

// Logrus structured logging setup
var (
	mlLogFields = log.Fields{
		"app":       "openmatch",
		"component": "mmlogic",
		"caller":    "mmlogicapi/apisrv/apisrv.go",
	}
	mlLog = log.WithFields(mlLogFields)
)

// MmlogicAPI implements mmlogic.ApiServer, the server generated by compiling
// the protobuf, by fulfilling the mmlogic.APIClient interface.
type MmlogicAPI struct {
	grpc *grpc.Server
	cfg  *viper.Viper
	pool *redis.Pool
}
type mmlogicAPI MmlogicAPI

// New returns an instantiated srvice
func New(cfg *viper.Viper, pool *redis.Pool) *MmlogicAPI {
	s := MmlogicAPI{
		pool: pool,
		grpc: grpc.NewServer(grpc.StatsHandler(&ocgrpc.ServerHandler{})),
		cfg:  cfg,
	}

	// Add a hook to the logger to auto-count log lines for metrics output thru OpenCensus
	log.AddHook(metrics.NewHook(MlLogLines, KeySeverity))

	// Register gRPC server
	mmlogic.RegisterAPIServer(s.grpc, (*mmlogicAPI)(&s))
	mlLog.Info("Successfully registered gRPC server")
	return &s
}

// Open opens the api grpc service, starting it listening on the configured port.
func (s *MmlogicAPI) Open() error {
	ln, err := net.Listen("tcp", ":"+s.cfg.GetString("api.mmlogic.port"))
	if err != nil {
		mlLog.WithFields(log.Fields{
			"error": err.Error(),
			"port":  s.cfg.GetInt("api.mmlogic.port"),
		}).Error("net.Listen() error")
		return err
	}
	mlLog.WithFields(log.Fields{"port": s.cfg.GetInt("api.mmlogic.port")}).Info("TCP net listener initialized")

	go func() {
		err := s.grpc.Serve(ln)
		if err != nil {
			mlLog.WithFields(log.Fields{"error": err.Error()}).Error("gRPC serve() error")
		}
		mlLog.Info("serving gRPC endpoints")
	}()

	return nil
}

// GetProfile is this service's implementation of the gRPC call defined in
// mmlogicapi/proto/mmlogic.proto
func (s *mmlogicAPI) GetProfile(c context.Context, in *mmlogic.Profile) (*mmlogic.Profile, error) {

	// Get redis connection from pool
	redisConn := s.pool.Get()
	defer redisConn.Close()

	// Create context for tagging OpenCensus metrics.
	funcName := "RetrieveProfile"
	fnCtx, _ := tag.New(c, tag.Insert(KeyMethod, funcName))

	mlLog.WithFields(log.Fields{"profileid": in.Id}).Info("Attempting retreival of profile")

	// Write group
	properties, err := redis.String(redisConn.Do("GET", in.Id))
	if err != nil {
		mlLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
			"profileid": in.Id,
		}).Error("State storage error")

		stats.Record(fnCtx, MlGrpcErrors.M(1))
		return &mmlogic.Profile{Id: in.Id, Properties: ""}, err
	}

	//TODO: read filterset here, and put it in the object.

	stats.Record(fnCtx, MlGrpcRequests.M(1))
	return &mmlogic.Profile{Id: in.Id, Properties: properties}, err

}

// AddtoIgnorelist is this service's implementation of the gRPC call defined in
// mmlogicapi/proto/mmlogic.proto
func (s *mmlogicAPI) CreateProposal(c context.Context, mo *mmlogic.MatchObject) (*mmlogic.Result, error) {

	list := s.cfg.GetString("ignoreLists.proposedPlayers")

	// Get redis connection from pool
	redisConn := s.pool.Get()
	defer redisConn.Close()

	// Create context for tagging OpenCensus metrics.
	funcName := "CreateProposal"
	fnCtx, _ := tag.New(c, tag.Insert(KeyMethod, funcName))

	mlLog.Info("Attempting to create proposal")

	// update ignorelist
	playerIDs := getPlayerIdsFromRoster(mo.Roster)
	err := ignorelist.Update(redisConn, list, playerIDs)
	if err != nil {
		// TODO: update fields
		mlLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
			"key":       list,
		}).Error("State storage error")

		stats.Record(fnCtx, MlGrpcErrors.M(1))
		return &mmlogic.Result{Success: false, Error: err.Error()}, err
	}

	// TODO: Write match object

	//  TODO; add propkey to proposalsq

	// TODO: decrement running MMFs

	stats.Record(fnCtx, MlGrpcRequests.M(1))
	return &mmlogic.Result{Success: true, Error: ""}, err

}

func (s *mmlogicAPI) CreateMatchObject(c context.Context, mo *mmlogic.MatchObject) (*mmlogic.Result, error) {

	list := s.cfg.GetString("ignoreLists.deindexedPlayers")

	// Get redis connection from pool
	redisConn := s.pool.Get()
	defer redisConn.Close()

	// Create context for tagging OpenCensus metrics.
	funcName := "CreateMatchObject"
	fnCtx, _ := tag.New(c, tag.Insert(KeyMethod, funcName))

	mlLog.Info("Attempting to create match object")

	// Write group
	playerIDs := getPlayerIdsFromRoster(mo.Roster)
	err := ignorelist.Update(redisConn, list, playerIDs)
	if err != nil {
		// TODO: update fields
		mlLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
			"key":       list,
		}).Error("State storage error")

		stats.Record(fnCtx, MlGrpcErrors.M(1))
		return &mmlogic.Result{Success: false, Error: err.Error()}, err
	}

	// TODO: deindex
	// for playerID in mo.Roster.Profile
	//	go player.Deindex(playerID)

	// TODO: wite match to key

	// TODO: decrement the running MMFs

	return &mmlogic.Result{Success: true, Error: ""}, err
}

func (s *mmlogicAPI) ListPlayers(c context.Context, f *mmlogic.Filter) (*mmlogic.Roster, error) {
	return &mmlogic.Roster{}, nil
}

func (s *mmlogicAPI) GetPlayerPool(c context.Context, fs *mmlogic.FilterSet) (*mmlogic.Roster, error) {
	return &mmlogic.Roster{}, nil
}

func (s *mmlogicAPI) ListIgnoredPlayers(c context.Context, olderThan *mmlogic.Timestamp) (*mmlogic.Roster, error) {

	list := s.cfg.GetString("ignoreLists.proposedPlayers")

	// Get redis connection from pool
	redisConn := s.pool.Get()
	defer redisConn.Close()

	// Create context for tagging OpenCensus metrics.
	funcName := "RetrieveIgnoreList"
	fnCtx, _ := tag.New(c, tag.Insert(KeyMethod, funcName))

	mlLog.Info("Attempting to retreive ignorelist")

	// retreive ignore list
	il, err := ignorelist.Retrieve(redisConn, list, olderThan.Ts)
	if err != nil {
		mlLog.WithFields(log.Fields{
			"error":     err.Error(),
			"component": "statestorage",
			"key":       list,
		}).Error("State storage error")

		stats.Record(fnCtx, MlGrpcErrors.M(1))
		return &mmlogic.Roster{}, err
	}
	// TODO: fix this
	mlLog.Debug(fmt.Sprintf("Retreival success %v", il))

	stats.Record(fnCtx, MlGrpcRequests.M(1))
	return createRosterfromPlayerIds(il), err
}
func (s *mmlogicAPI) GetCombinedIgnoreList(c context.Context, in *mmlogic.Input) (*mmlogic.Roster, error) {

	// Get redis connection from pool
	redisConn := s.pool.Get()
	defer redisConn.Close()

	// Create context for tagging OpenCensus metrics.
	funcName := "GetCombinedIgnoreList"
	//fnCtx, _ := tag.New(c, tag.Insert(KeyMethod, funcName))

	il := make([]string, 0)
	err := errors.New("")

	for _, il := range s.cfg.GetStringMapString("ignoreLists") {
		mlLog.Info(funcName, " Found IL named ", il)
	}

	return createRosterfromPlayerIds(il), err
}

func getPlayerIdsFromRoster(r *mmlogic.Roster) []string {
	playerIDs := make([]string, 0)
	for _, prof := range r.Profile {
		playerIDs = append(playerIDs, prof.Id)
	}
	return playerIDs

}

func createRosterfromPlayerIds(playerIDs []string) *mmlogic.Roster {

	profiles := make([]*mmlogic.Profile, 0)
	for _, id := range playerIDs {
		profiles = append(profiles, &mmlogic.Profile{Id: id})
	}
	return &mmlogic.Roster{Profile: profiles}

}
