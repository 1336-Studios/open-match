// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mmlogic.proto

/*
Package mmlogic is a generated protocol buffer package.

It is generated from these files:
	mmlogic.proto

It has these top-level messages:
	Result
	Roster
	Profile
	Timestamp
	FilterSet
	Filter
	Input
	MatchObject
*/
package mmlogic

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Simple message to return success/failure and error status.
type Result struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Result) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Data structure to hold a list of players in a match.
type Roster struct {
	// repeated string player_ids = 1;  // By convention, UUIDs
	Profile   []*Profile `protobuf:"bytes,1,rep,name=profile" json:"profile,omitempty"`
	Filterset *FilterSet `protobuf:"bytes,2,opt,name=filterset" json:"filterset,omitempty"`
}

func (m *Roster) Reset()                    { *m = Roster{} }
func (m *Roster) String() string            { return proto.CompactTextString(m) }
func (*Roster) ProtoMessage()               {}
func (*Roster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Roster) GetProfile() []*Profile {
	if m != nil {
		return m.Profile
	}
	return nil
}

func (m *Roster) GetFilterset() *FilterSet {
	if m != nil {
		return m.Filterset
	}
	return nil
}

// Data structure for a profile to pass to the matchmaking function.
type Profile struct {
	Id         string     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string     `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Filterset  *FilterSet `protobuf:"bytes,3,opt,name=filterset" json:"filterset,omitempty"`
}

func (m *Profile) Reset()                    { *m = Profile{} }
func (m *Profile) String() string            { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()               {}
func (*Profile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Profile) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Profile) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Profile) GetFilterset() *FilterSet {
	if m != nil {
		return m.Filterset
	}
	return nil
}

// Epoch timestamp in seconds.
type Timestamp struct {
	Ts int64 `protobuf:"varint,1,opt,name=ts" json:"ts,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Timestamp) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

// Set of filters to apply to the player pool.
type FilterSet struct {
	Filter []*Filter `protobuf:"bytes,1,rep,name=filter" json:"filter,omitempty"`
}

func (m *FilterSet) Reset()                    { *m = FilterSet{} }
func (m *FilterSet) String() string            { return proto.CompactTextString(m) }
func (*FilterSet) ProtoMessage()               {}
func (*FilterSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *FilterSet) GetFilter() []*Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

// A filter to apply to the player pool.
type Filter struct {
	Field      string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	MinValue   int64  `protobuf:"varint,2,opt,name=min_value,json=minValue" json:"min_value,omitempty"`
	MaxValue   int64  `protobuf:"varint,3,opt,name=max_value,json=maxValue" json:"max_value,omitempty"`
	NumMatched int64  `protobuf:"varint,4,opt,name=num_matched,json=numMatched" json:"num_matched,omitempty"`
	Limit      int64  `protobuf:"varint,5,opt,name=limit" json:"limit,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Filter) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *Filter) GetMinValue() int64 {
	if m != nil {
		return m.MinValue
	}
	return 0
}

func (m *Filter) GetMaxValue() int64 {
	if m != nil {
		return m.MaxValue
	}
	return 0
}

func (m *Filter) GetNumMatched() int64 {
	if m != nil {
		return m.NumMatched
	}
	return 0
}

func (m *Filter) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// Empty Message, but defining something so we can add fields without breaking backwards compatibility
type Input struct {
}

func (m *Input) Reset()                    { *m = Input{} }
func (m *Input) String() string            { return proto.CompactTextString(m) }
func (*Input) ProtoMessage()               {}
func (*Input) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// Data structure for all the properties of a match.
type MatchObject struct {
	Id         string  `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string  `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Roster     *Roster `protobuf:"bytes,3,opt,name=roster" json:"roster,omitempty"`
}

func (m *MatchObject) Reset()                    { *m = MatchObject{} }
func (m *MatchObject) String() string            { return proto.CompactTextString(m) }
func (*MatchObject) ProtoMessage()               {}
func (*MatchObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *MatchObject) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MatchObject) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *MatchObject) GetRoster() *Roster {
	if m != nil {
		return m.Roster
	}
	return nil
}

func init() {
	proto.RegisterType((*Result)(nil), "Result")
	proto.RegisterType((*Roster)(nil), "Roster")
	proto.RegisterType((*Profile)(nil), "Profile")
	proto.RegisterType((*Timestamp)(nil), "Timestamp")
	proto.RegisterType((*FilterSet)(nil), "FilterSet")
	proto.RegisterType((*Filter)(nil), "Filter")
	proto.RegisterType((*Input)(nil), "Input")
	proto.RegisterType((*MatchObject)(nil), "MatchObject")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for API service

type APIClient interface {
	// Profile and match object functions
	// If your matchmaking logic makes a group, it should either make a Proposal
	// or a Match Object (but only one of the two).  For more details about which
	// you should create, refer to the documentation.
	//
	// Send RetreiveProfile an profile ID with an empty properties field, it will return a 'filled' one.
	GetProfile(ctx context.Context, in *Profile, opts ...grpc.CallOption) (*Profile, error)
	//
	// CreateProposal  does the following:
	//  - adds all players in the Roster to the proposed player ignore list
	//  - writes the proposed match to the provided key
	//  - adds that key to the list of proposals to be considered
	//  - decrements the number of running MMFs
	CreateProposal(ctx context.Context, in *MatchObject, opts ...grpc.CallOption) (*Result, error)
	//
	//  CreateMatchObject does the following:
	//  - adds all players in the Roster to the deindexed player ignore list
	//  - kicks off a lazy deindex of all players in the Roster
	//  - writes the match to the provided key
	//  - decrements the number of running MMFs
	CreateMatchObject(ctx context.Context, in *MatchObject, opts ...grpc.CallOption) (*Result, error)
	// Player listing and filtering functions
	//
	ListPlayers(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*Roster, error)
	// RetrievePlayerPool runs ListFilteredPlayers for every Filter in the input FilterSet, and then
	// removes all players returned by a call to RetrieveCombinedIgnoreList.  It returns the resulting
	// player pool.
	GetPlayerPool(ctx context.Context, in *FilterSet, opts ...grpc.CallOption) (*Roster, error)
	// Ignore List functions
	//
	// RetrieveIgnoreList retrieves players from the
	// 'ignoreLists.proposedPlayers' ignore list specified in the config file
	// that were placed on the list before the provided timestamp.  To retrieve
	// all players on the list, provide the current time as the timestamp.
	ListIgnoredPlayers(ctx context.Context, in *Timestamp, opts ...grpc.CallOption) (*Roster, error)
	//
	GetCombinedIgnoreList(ctx context.Context, in *Input, opts ...grpc.CallOption) (*Roster, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) GetProfile(ctx context.Context, in *Profile, opts ...grpc.CallOption) (*Profile, error) {
	out := new(Profile)
	err := grpc.Invoke(ctx, "/API/GetProfile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreateProposal(ctx context.Context, in *MatchObject, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/API/CreateProposal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreateMatchObject(ctx context.Context, in *MatchObject, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/API/CreateMatchObject", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListPlayers(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*Roster, error) {
	out := new(Roster)
	err := grpc.Invoke(ctx, "/API/ListPlayers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetPlayerPool(ctx context.Context, in *FilterSet, opts ...grpc.CallOption) (*Roster, error) {
	out := new(Roster)
	err := grpc.Invoke(ctx, "/API/GetPlayerPool", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListIgnoredPlayers(ctx context.Context, in *Timestamp, opts ...grpc.CallOption) (*Roster, error) {
	out := new(Roster)
	err := grpc.Invoke(ctx, "/API/ListIgnoredPlayers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetCombinedIgnoreList(ctx context.Context, in *Input, opts ...grpc.CallOption) (*Roster, error) {
	out := new(Roster)
	err := grpc.Invoke(ctx, "/API/GetCombinedIgnoreList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for API service

type APIServer interface {
	// Profile and match object functions
	// If your matchmaking logic makes a group, it should either make a Proposal
	// or a Match Object (but only one of the two).  For more details about which
	// you should create, refer to the documentation.
	//
	// Send RetreiveProfile an profile ID with an empty properties field, it will return a 'filled' one.
	GetProfile(context.Context, *Profile) (*Profile, error)
	//
	// CreateProposal  does the following:
	//  - adds all players in the Roster to the proposed player ignore list
	//  - writes the proposed match to the provided key
	//  - adds that key to the list of proposals to be considered
	//  - decrements the number of running MMFs
	CreateProposal(context.Context, *MatchObject) (*Result, error)
	//
	//  CreateMatchObject does the following:
	//  - adds all players in the Roster to the deindexed player ignore list
	//  - kicks off a lazy deindex of all players in the Roster
	//  - writes the match to the provided key
	//  - decrements the number of running MMFs
	CreateMatchObject(context.Context, *MatchObject) (*Result, error)
	// Player listing and filtering functions
	//
	ListPlayers(context.Context, *Filter) (*Roster, error)
	// RetrievePlayerPool runs ListFilteredPlayers for every Filter in the input FilterSet, and then
	// removes all players returned by a call to RetrieveCombinedIgnoreList.  It returns the resulting
	// player pool.
	GetPlayerPool(context.Context, *FilterSet) (*Roster, error)
	// Ignore List functions
	//
	// RetrieveIgnoreList retrieves players from the
	// 'ignoreLists.proposedPlayers' ignore list specified in the config file
	// that were placed on the list before the provided timestamp.  To retrieve
	// all players on the list, provide the current time as the timestamp.
	ListIgnoredPlayers(context.Context, *Timestamp) (*Roster, error)
	//
	GetCombinedIgnoreList(context.Context, *Input) (*Roster, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Profile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/GetProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetProfile(ctx, req.(*Profile))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreateProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/CreateProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateProposal(ctx, req.(*MatchObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreateMatchObject_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateMatchObject(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/CreateMatchObject",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateMatchObject(ctx, req.(*MatchObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListPlayers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListPlayers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/ListPlayers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListPlayers(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetPlayerPool_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilterSet)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetPlayerPool(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/GetPlayerPool",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetPlayerPool(ctx, req.(*FilterSet))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListIgnoredPlayers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Timestamp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListIgnoredPlayers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/ListIgnoredPlayers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListIgnoredPlayers(ctx, req.(*Timestamp))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetCombinedIgnoreList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Input)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetCombinedIgnoreList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/GetCombinedIgnoreList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetCombinedIgnoreList(ctx, req.(*Input))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProfile",
			Handler:    _API_GetProfile_Handler,
		},
		{
			MethodName: "CreateProposal",
			Handler:    _API_CreateProposal_Handler,
		},
		{
			MethodName: "CreateMatchObject",
			Handler:    _API_CreateMatchObject_Handler,
		},
		{
			MethodName: "ListPlayers",
			Handler:    _API_ListPlayers_Handler,
		},
		{
			MethodName: "GetPlayerPool",
			Handler:    _API_GetPlayerPool_Handler,
		},
		{
			MethodName: "ListIgnoredPlayers",
			Handler:    _API_ListIgnoredPlayers_Handler,
		},
		{
			MethodName: "GetCombinedIgnoreList",
			Handler:    _API_GetCombinedIgnoreList_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "mmlogic.proto",
}

func init() { proto.RegisterFile("mmlogic.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 471 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0x41, 0x8b, 0xd4, 0x4c,
	0x10, 0x9d, 0x49, 0xbe, 0x49, 0x26, 0x95, 0x6f, 0x17, 0x6c, 0x14, 0xc2, 0x2c, 0x38, 0x63, 0x1f,
	0x64, 0xd4, 0x25, 0x87, 0xf1, 0xe2, 0x55, 0x16, 0x5c, 0x06, 0x14, 0x43, 0x2b, 0x7b, 0x74, 0xc9,
	0x24, 0x35, 0x6b, 0x4b, 0x77, 0x3a, 0x74, 0x77, 0x64, 0xfd, 0x15, 0xfe, 0x0b, 0x7f, 0xa7, 0xa4,
	0x3b, 0x19, 0xe3, 0x41, 0xc1, 0x5b, 0xea, 0xbd, 0x57, 0x55, 0xaf, 0xab, 0x2a, 0x70, 0x26, 0xa5,
	0x50, 0x77, 0xbc, 0xca, 0x5b, 0xad, 0xac, 0xa2, 0xaf, 0x20, 0x62, 0x68, 0x3a, 0x61, 0x49, 0x06,
	0xb1, 0xe9, 0xaa, 0x0a, 0x8d, 0xc9, 0xe6, 0x9b, 0xf9, 0x76, 0xc9, 0xc6, 0x90, 0x3c, 0x84, 0x05,
	0x6a, 0xad, 0x74, 0x16, 0x6c, 0xe6, 0xdb, 0x84, 0xf9, 0x80, 0xde, 0x40, 0xc4, 0x94, 0xb1, 0xa8,
	0x09, 0x85, 0xb8, 0xd5, 0xea, 0xc8, 0x05, 0x66, 0xf3, 0x4d, 0xb8, 0x4d, 0x77, 0xcb, 0xbc, 0xf0,
	0x31, 0x1b, 0x09, 0xb2, 0x85, 0xe4, 0xc8, 0x85, 0x45, 0x6d, 0xd0, 0xba, 0x3a, 0xe9, 0x0e, 0xf2,
	0x37, 0x0e, 0xf9, 0x80, 0x96, 0xfd, 0x22, 0x69, 0x05, 0xf1, 0x90, 0x4d, 0xce, 0x21, 0xe0, 0xb5,
	0x73, 0x93, 0xb0, 0x80, 0xd7, 0xe4, 0x31, 0x40, 0xab, 0x55, 0x8b, 0xda, 0x72, 0x34, 0x83, 0x9b,
	0x09, 0xf2, 0x7b, 0x93, 0xf0, 0x6f, 0x4d, 0x2e, 0x20, 0xf9, 0xc8, 0x25, 0x1a, 0x5b, 0xca, 0xb6,
	0x6f, 0x63, 0xfd, 0xa3, 0x43, 0x16, 0x58, 0x43, 0x2f, 0x21, 0x39, 0x25, 0x91, 0x35, 0x44, 0x3e,
	0x6d, 0x78, 0x5b, 0x3c, 0x14, 0x64, 0x03, 0x4c, 0xbf, 0xcf, 0x21, 0xf2, 0x50, 0x3f, 0xa8, 0x23,
	0x47, 0x31, 0x5a, 0xf6, 0x01, 0xb9, 0x80, 0x44, 0xf2, 0xe6, 0xf6, 0x6b, 0x29, 0x3a, 0x74, 0xa6,
	0x43, 0xb6, 0x94, 0xbc, 0xb9, 0xe9, 0x63, 0x47, 0x96, 0xf7, 0x03, 0x19, 0x0e, 0x64, 0x79, 0xef,
	0xc9, 0x35, 0xa4, 0x4d, 0x27, 0x6f, 0x65, 0x69, 0xab, 0xcf, 0x58, 0x67, 0xff, 0x39, 0x1a, 0x9a,
	0x4e, 0xbe, 0xf3, 0x48, 0xdf, 0x50, 0x70, 0xc9, 0x6d, 0xb6, 0x70, 0x94, 0x0f, 0x68, 0x0c, 0x8b,
	0x7d, 0xd3, 0x76, 0x96, 0x7e, 0x82, 0xd4, 0x29, 0xdf, 0x1f, 0xbe, 0x60, 0x65, 0xff, 0x79, 0x9c,
	0x6b, 0x88, 0xb4, 0xdb, 0xf0, 0x30, 0xcb, 0x38, 0xf7, 0x0b, 0x67, 0x03, 0xbc, 0xfb, 0x11, 0x40,
	0xf8, 0xba, 0xd8, 0x13, 0x0a, 0x70, 0x8d, 0x76, 0xdc, 0xda, 0x69, 0xfb, 0xab, 0xd3, 0x17, 0x9d,
	0x91, 0x67, 0x70, 0x7e, 0xa5, 0xb1, 0xb4, 0x58, 0x68, 0xd5, 0x2a, 0x53, 0x0a, 0xf2, 0x7f, 0x3e,
	0x31, 0xb7, 0x8a, 0x73, 0x7f, 0x87, 0x74, 0x46, 0x2e, 0xe1, 0x81, 0x97, 0x4e, 0xcd, 0xff, 0x51,
	0xfd, 0x04, 0xd2, 0xb7, 0xdc, 0xd8, 0x42, 0x94, 0xdf, 0x50, 0x1b, 0x32, 0xee, 0x67, 0x35, 0xba,
	0xa5, 0x33, 0xf2, 0x14, 0xce, 0x7a, 0x7f, 0x4e, 0x51, 0x28, 0x25, 0xc8, 0xe4, 0x2a, 0xa6, 0xba,
	0x17, 0x40, 0xfa, 0x52, 0xfb, 0xbb, 0x46, 0x69, 0xac, 0xc7, 0x8a, 0x90, 0x9f, 0x4e, 0x65, 0x2a,
	0x7e, 0x0e, 0x8f, 0xae, 0xd1, 0x5e, 0x29, 0x79, 0xe0, 0x0d, 0xd6, 0x3e, 0xa7, 0xcf, 0x26, 0x51,
	0xee, 0xa6, 0x3f, 0xd1, 0x1e, 0x22, 0xf7, 0xb3, 0xbd, 0xfc, 0x19, 0x00, 0x00, 0xff, 0xff, 0x1b,
	0x26, 0x5a, 0xb8, 0x7d, 0x03, 0x00, 0x00,
}
