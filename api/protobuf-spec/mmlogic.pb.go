// Code generated by protoc-gen-go. DO NOT EDIT.
// source: mmlogic.proto

/*
Package mmlogic is a generated protocol buffer package.

It is generated from these files:
	mmlogic.proto

It has these top-level messages:
	MMFResults
	MatchObject
	Roster
	Result
	Profile
	IlInput
	FilterSet
	Filter
	FilterSpec
	FilterStat
	JsonFilterSet
	PlayerPool
	Player
	Property
	Timestamp
*/
package mmlogic

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Proposals are the proposed match object and roster.
type MMFResults struct {
	Id          string       `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Matchobject *MatchObject `protobuf:"bytes,2,opt,name=matchobject" json:"matchobject,omitempty"`
	Roster      *Roster      `protobuf:"bytes,3,opt,name=roster" json:"roster,omitempty"`
}

func (m *MMFResults) Reset()                    { *m = MMFResults{} }
func (m *MMFResults) String() string            { return proto.CompactTextString(m) }
func (*MMFResults) ProtoMessage()               {}
func (*MMFResults) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *MMFResults) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MMFResults) GetMatchobject() *MatchObject {
	if m != nil {
		return m.Matchobject
	}
	return nil
}

func (m *MMFResults) GetRoster() *Roster {
	if m != nil {
		return m.Roster
	}
	return nil
}

// Data structure for all the properties of a match.
type MatchObject struct {
	Id         string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
}

func (m *MatchObject) Reset()                    { *m = MatchObject{} }
func (m *MatchObject) String() string            { return proto.CompactTextString(m) }
func (*MatchObject) ProtoMessage()               {}
func (*MatchObject) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *MatchObject) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *MatchObject) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

// Data structure to hold a list of players in a match.
type Roster struct {
	Id        string     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Players   []*Player  `protobuf:"bytes,2,rep,name=players" json:"players,omitempty"`
	FilterSet *FilterSet `protobuf:"bytes,3,opt,name=filter_set,json=filterSet" json:"filter_set,omitempty"`
}

func (m *Roster) Reset()                    { *m = Roster{} }
func (m *Roster) String() string            { return proto.CompactTextString(m) }
func (*Roster) ProtoMessage()               {}
func (*Roster) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Roster) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Roster) GetPlayers() []*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *Roster) GetFilterSet() *FilterSet {
	if m != nil {
		return m.FilterSet
	}
	return nil
}

// Simple message to return success/failure and error status.
type Result struct {
	Success bool   `protobuf:"varint,1,opt,name=success" json:"success,omitempty"`
	Error   string `protobuf:"bytes,2,opt,name=error" json:"error,omitempty"`
}

func (m *Result) Reset()                    { *m = Result{} }
func (m *Result) String() string            { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()               {}
func (*Result) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Result) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *Result) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// Data structure for a profile to pass to the matchmaking function.
type Profile struct {
	Id         string     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties string     `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	Filterset  *FilterSet `protobuf:"bytes,3,opt,name=filterset" json:"filterset,omitempty"`
}

func (m *Profile) Reset()                    { *m = Profile{} }
func (m *Profile) String() string            { return proto.CompactTextString(m) }
func (*Profile) ProtoMessage()               {}
func (*Profile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Profile) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Profile) GetProperties() string {
	if m != nil {
		return m.Properties
	}
	return ""
}

func (m *Profile) GetFilterset() *FilterSet {
	if m != nil {
		return m.Filterset
	}
	return nil
}

// Empty Message, but defining something so we can add fields without breaking backwards compatibility
type IlInput struct {
}

func (m *IlInput) Reset()                    { *m = IlInput{} }
func (m *IlInput) String() string            { return proto.CompactTextString(m) }
func (*IlInput) ProtoMessage()               {}
func (*IlInput) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Set of filters to apply to the player pool.
type FilterSet struct {
	Id      string    `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Filters []*Filter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
}

func (m *FilterSet) Reset()                    { *m = FilterSet{} }
func (m *FilterSet) String() string            { return proto.CompactTextString(m) }
func (*FilterSet) ProtoMessage()               {}
func (*FilterSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FilterSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FilterSet) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// A filter to apply to the player pool.
type Filter struct {
	Id         string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	FilterSpec *FilterSpec `protobuf:"bytes,2,opt,name=filter_spec,json=filterSpec" json:"filter_spec,omitempty"`
	FilterStat *FilterStat `protobuf:"bytes,3,opt,name=filter_stat,json=filterStat" json:"filter_stat,omitempty"`
}

func (m *Filter) Reset()                    { *m = Filter{} }
func (m *Filter) String() string            { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()               {}
func (*Filter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Filter) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Filter) GetFilterSpec() *FilterSpec {
	if m != nil {
		return m.FilterSpec
	}
	return nil
}

func (m *Filter) GetFilterStat() *FilterStat {
	if m != nil {
		return m.FilterStat
	}
	return nil
}

type FilterSpec struct {
	Field string `protobuf:"bytes,1,opt,name=field" json:"field,omitempty"`
	Minv  int64  `protobuf:"varint,2,opt,name=minv" json:"minv,omitempty"`
	Maxv  int64  `protobuf:"varint,3,opt,name=maxv" json:"maxv,omitempty"`
}

func (m *FilterSpec) Reset()                    { *m = FilterSpec{} }
func (m *FilterSpec) String() string            { return proto.CompactTextString(m) }
func (*FilterSpec) ProtoMessage()               {}
func (*FilterSpec) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *FilterSpec) GetField() string {
	if m != nil {
		return m.Field
	}
	return ""
}

func (m *FilterSpec) GetMinv() int64 {
	if m != nil {
		return m.Minv
	}
	return 0
}

func (m *FilterSpec) GetMaxv() int64 {
	if m != nil {
		return m.Maxv
	}
	return 0
}

type FilterStat struct {
	Count   int64   `protobuf:"varint,1,opt,name=count" json:"count,omitempty"`
	Elapsed float64 `protobuf:"fixed64,2,opt,name=elapsed" json:"elapsed,omitempty"`
}

func (m *FilterStat) Reset()                    { *m = FilterStat{} }
func (m *FilterStat) String() string            { return proto.CompactTextString(m) }
func (*FilterStat) ProtoMessage()               {}
func (*FilterStat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *FilterStat) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *FilterStat) GetElapsed() float64 {
	if m != nil {
		return m.Elapsed
	}
	return 0
}

// JSON representation of a FilterSet.  Must be able to be read by golang's jsonpb.UnmarshalString()
type JsonFilterSet struct {
	Id   string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Json string `protobuf:"bytes,2,opt,name=json" json:"json,omitempty"`
}

func (m *JsonFilterSet) Reset()                    { *m = JsonFilterSet{} }
func (m *JsonFilterSet) String() string            { return proto.CompactTextString(m) }
func (*JsonFilterSet) ProtoMessage()               {}
func (*JsonFilterSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *JsonFilterSet) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *JsonFilterSet) GetJson() string {
	if m != nil {
		return m.Json
	}
	return ""
}

// Keep sending until no more to send, then close channel
type PlayerPool struct {
	Id            string         `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Count         int64          `protobuf:"varint,2,opt,name=count" json:"count,omitempty"`
	Roster        *Roster        `protobuf:"bytes,3,opt,name=roster" json:"roster,omitempty"`
	JsonFilterSet *JsonFilterSet `protobuf:"bytes,4,opt,name=json_filter_set,json=jsonFilterSet" json:"json_filter_set,omitempty"`
}

func (m *PlayerPool) Reset()                    { *m = PlayerPool{} }
func (m *PlayerPool) String() string            { return proto.CompactTextString(m) }
func (*PlayerPool) ProtoMessage()               {}
func (*PlayerPool) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *PlayerPool) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *PlayerPool) GetCount() int64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PlayerPool) GetRoster() *Roster {
	if m != nil {
		return m.Roster
	}
	return nil
}

func (m *PlayerPool) GetJsonFilterSet() *JsonFilterSet {
	if m != nil {
		return m.JsonFilterSet
	}
	return nil
}

// Data structure for a profile to pass to the matchmaking function.
type Player struct {
	Id         string      `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Properties []*Property `protobuf:"bytes,2,rep,name=properties" json:"properties,omitempty"`
}

func (m *Player) Reset()                    { *m = Player{} }
func (m *Player) String() string            { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()               {}
func (*Player) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Player) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Player) GetProperties() []*Property {
	if m != nil {
		return m.Properties
	}
	return nil
}

type Property struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value int64  `protobuf:"varint,2,opt,name=value" json:"value,omitempty"`
}

func (m *Property) Reset()                    { *m = Property{} }
func (m *Property) String() string            { return proto.CompactTextString(m) }
func (*Property) ProtoMessage()               {}
func (*Property) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Property) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Property) GetValue() int64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Epoch timestamp in seconds.
type Timestamp struct {
	Ts int64 `protobuf:"varint,1,opt,name=ts" json:"ts,omitempty"`
}

func (m *Timestamp) Reset()                    { *m = Timestamp{} }
func (m *Timestamp) String() string            { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()               {}
func (*Timestamp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *Timestamp) GetTs() int64 {
	if m != nil {
		return m.Ts
	}
	return 0
}

func init() {
	proto.RegisterType((*MMFResults)(nil), "MMFResults")
	proto.RegisterType((*MatchObject)(nil), "MatchObject")
	proto.RegisterType((*Roster)(nil), "Roster")
	proto.RegisterType((*Result)(nil), "Result")
	proto.RegisterType((*Profile)(nil), "Profile")
	proto.RegisterType((*IlInput)(nil), "IlInput")
	proto.RegisterType((*FilterSet)(nil), "FilterSet")
	proto.RegisterType((*Filter)(nil), "Filter")
	proto.RegisterType((*FilterSpec)(nil), "FilterSpec")
	proto.RegisterType((*FilterStat)(nil), "FilterStat")
	proto.RegisterType((*JsonFilterSet)(nil), "JsonFilterSet")
	proto.RegisterType((*PlayerPool)(nil), "PlayerPool")
	proto.RegisterType((*Player)(nil), "Player")
	proto.RegisterType((*Property)(nil), "Property")
	proto.RegisterType((*Timestamp)(nil), "Timestamp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for API service

type APIClient interface {
	// Profile and match object functions
	// If your matchmaking logic makes a group, it should either make a Proposal
	// or a Match Object (but only one of the two).  For more details about which
	// you should create, refer to the documentation.
	//
	// Send GetProfile an profile ID with an empty properties field, it will return a 'filled' one.
	//  Note that the filtersets are assumed to be checked by the backendapi
	//  when accepting a profile: the mmlogic api will choke on filter set JSON
	//  that the jsonpb module can't unmarshal to the FilterSet protobuf message!
	GetProfile(ctx context.Context, in *Profile, opts ...grpc.CallOption) (*Profile, error)
	// rpc GetFilterSet(FilterSet) returns (FilterSet) {}
	// rpc CreateFilterSet(JsonFilter) returns (FilterSet) {}
	GetProposal(ctx context.Context, in *MatchObject, opts ...grpc.CallOption) (*MatchObject, error)
	//
	// CreateProposal  does the following:
	//  - adds all players in the Roster to the proposed player ignore list
	//  - writes the proposed match to the provided key
	//  - adds that key to the list of proposals to be considered
	CreateProposal(ctx context.Context, in *MMFResults, opts ...grpc.CallOption) (*Result, error)
	// Player listing and filtering functions
	//
	ListPlayers(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*Roster, error)
	// RetrievePlayerPool runs ListFilteredPlayers for every Filter in the input FilterSet, and then
	// removes all players returned by a call to RetrieveCombinedIgnoreList.  It returns the resulting
	// player pool.
	GetPlayerPool(ctx context.Context, in *JsonFilterSet, opts ...grpc.CallOption) (API_GetPlayerPoolClient, error)
	// Ignore List functions
	//
	// RetrieveIgnoreList retrieves players from the
	// 'ignoreLists.proposedPlayers' ignore list specified in the config file
	// that were placed on the list before the provided timestamp.  To retrieve
	// all players on the list, provide the current time as the timestamp.
	ListIgnoredPlayers(ctx context.Context, in *Timestamp, opts ...grpc.CallOption) (*Roster, error)
	//
	GetCombinedIgnoreList(ctx context.Context, in *IlInput, opts ...grpc.CallOption) (*Roster, error)
}

type aPIClient struct {
	cc *grpc.ClientConn
}

func NewAPIClient(cc *grpc.ClientConn) APIClient {
	return &aPIClient{cc}
}

func (c *aPIClient) GetProfile(ctx context.Context, in *Profile, opts ...grpc.CallOption) (*Profile, error) {
	out := new(Profile)
	err := grpc.Invoke(ctx, "/API/GetProfile", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetProposal(ctx context.Context, in *MatchObject, opts ...grpc.CallOption) (*MatchObject, error) {
	out := new(MatchObject)
	err := grpc.Invoke(ctx, "/API/GetProposal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) CreateProposal(ctx context.Context, in *MMFResults, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := grpc.Invoke(ctx, "/API/CreateProposal", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) ListPlayers(ctx context.Context, in *Filter, opts ...grpc.CallOption) (*Roster, error) {
	out := new(Roster)
	err := grpc.Invoke(ctx, "/API/ListPlayers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetPlayerPool(ctx context.Context, in *JsonFilterSet, opts ...grpc.CallOption) (API_GetPlayerPoolClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_API_serviceDesc.Streams[0], c.cc, "/API/GetPlayerPool", opts...)
	if err != nil {
		return nil, err
	}
	x := &aPIGetPlayerPoolClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type API_GetPlayerPoolClient interface {
	Recv() (*PlayerPool, error)
	grpc.ClientStream
}

type aPIGetPlayerPoolClient struct {
	grpc.ClientStream
}

func (x *aPIGetPlayerPoolClient) Recv() (*PlayerPool, error) {
	m := new(PlayerPool)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *aPIClient) ListIgnoredPlayers(ctx context.Context, in *Timestamp, opts ...grpc.CallOption) (*Roster, error) {
	out := new(Roster)
	err := grpc.Invoke(ctx, "/API/ListIgnoredPlayers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *aPIClient) GetCombinedIgnoreList(ctx context.Context, in *IlInput, opts ...grpc.CallOption) (*Roster, error) {
	out := new(Roster)
	err := grpc.Invoke(ctx, "/API/GetCombinedIgnoreList", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for API service

type APIServer interface {
	// Profile and match object functions
	// If your matchmaking logic makes a group, it should either make a Proposal
	// or a Match Object (but only one of the two).  For more details about which
	// you should create, refer to the documentation.
	//
	// Send GetProfile an profile ID with an empty properties field, it will return a 'filled' one.
	//  Note that the filtersets are assumed to be checked by the backendapi
	//  when accepting a profile: the mmlogic api will choke on filter set JSON
	//  that the jsonpb module can't unmarshal to the FilterSet protobuf message!
	GetProfile(context.Context, *Profile) (*Profile, error)
	// rpc GetFilterSet(FilterSet) returns (FilterSet) {}
	// rpc CreateFilterSet(JsonFilter) returns (FilterSet) {}
	GetProposal(context.Context, *MatchObject) (*MatchObject, error)
	//
	// CreateProposal  does the following:
	//  - adds all players in the Roster to the proposed player ignore list
	//  - writes the proposed match to the provided key
	//  - adds that key to the list of proposals to be considered
	CreateProposal(context.Context, *MMFResults) (*Result, error)
	// Player listing and filtering functions
	//
	ListPlayers(context.Context, *Filter) (*Roster, error)
	// RetrievePlayerPool runs ListFilteredPlayers for every Filter in the input FilterSet, and then
	// removes all players returned by a call to RetrieveCombinedIgnoreList.  It returns the resulting
	// player pool.
	GetPlayerPool(*JsonFilterSet, API_GetPlayerPoolServer) error
	// Ignore List functions
	//
	// RetrieveIgnoreList retrieves players from the
	// 'ignoreLists.proposedPlayers' ignore list specified in the config file
	// that were placed on the list before the provided timestamp.  To retrieve
	// all players on the list, provide the current time as the timestamp.
	ListIgnoredPlayers(context.Context, *Timestamp) (*Roster, error)
	//
	GetCombinedIgnoreList(context.Context, *IlInput) (*Roster, error)
}

func RegisterAPIServer(s *grpc.Server, srv APIServer) {
	s.RegisterService(&_API_serviceDesc, srv)
}

func _API_GetProfile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Profile)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetProfile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/GetProfile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetProfile(ctx, req.(*Profile))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MatchObject)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/GetProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetProposal(ctx, req.(*MatchObject))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_CreateProposal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MMFResults)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).CreateProposal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/CreateProposal",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).CreateProposal(ctx, req.(*MMFResults))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_ListPlayers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Filter)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListPlayers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/ListPlayers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListPlayers(ctx, req.(*Filter))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetPlayerPool_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(JsonFilterSet)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(APIServer).GetPlayerPool(m, &aPIGetPlayerPoolServer{stream})
}

type API_GetPlayerPoolServer interface {
	Send(*PlayerPool) error
	grpc.ServerStream
}

type aPIGetPlayerPoolServer struct {
	grpc.ServerStream
}

func (x *aPIGetPlayerPoolServer) Send(m *PlayerPool) error {
	return x.ServerStream.SendMsg(m)
}

func _API_ListIgnoredPlayers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Timestamp)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).ListIgnoredPlayers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/ListIgnoredPlayers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).ListIgnoredPlayers(ctx, req.(*Timestamp))
	}
	return interceptor(ctx, in, info, handler)
}

func _API_GetCombinedIgnoreList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IlInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(APIServer).GetCombinedIgnoreList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/API/GetCombinedIgnoreList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(APIServer).GetCombinedIgnoreList(ctx, req.(*IlInput))
	}
	return interceptor(ctx, in, info, handler)
}

var _API_serviceDesc = grpc.ServiceDesc{
	ServiceName: "API",
	HandlerType: (*APIServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetProfile",
			Handler:    _API_GetProfile_Handler,
		},
		{
			MethodName: "GetProposal",
			Handler:    _API_GetProposal_Handler,
		},
		{
			MethodName: "CreateProposal",
			Handler:    _API_CreateProposal_Handler,
		},
		{
			MethodName: "ListPlayers",
			Handler:    _API_ListPlayers_Handler,
		},
		{
			MethodName: "ListIgnoredPlayers",
			Handler:    _API_ListIgnoredPlayers_Handler,
		},
		{
			MethodName: "GetCombinedIgnoreList",
			Handler:    _API_GetCombinedIgnoreList_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetPlayerPool",
			Handler:       _API_GetPlayerPool_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "mmlogic.proto",
}

func init() { proto.RegisterFile("mmlogic.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 633 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0x5b, 0x6b, 0xdb, 0x4c,
	0x10, 0xf5, 0x25, 0x9f, 0x2f, 0xa3, 0xcf, 0x29, 0x2c, 0x2d, 0x18, 0x17, 0xda, 0x64, 0x9f, 0x1c,
	0x12, 0x44, 0x48, 0x4a, 0xe9, 0x43, 0x5b, 0x28, 0x81, 0x04, 0x87, 0x86, 0x9a, 0x6d, 0xdf, 0xc3,
	0x46, 0x1e, 0xa7, 0x0a, 0x92, 0x56, 0x68, 0xc7, 0x26, 0xf9, 0x0d, 0xfd, 0x33, 0xfd, 0x89, 0x65,
	0x6f, 0x8a, 0x5c, 0xf7, 0x42, 0xdf, 0x66, 0x8e, 0x66, 0xce, 0x1c, 0x9d, 0x9d, 0x5d, 0x18, 0xe5,
	0x79, 0xa6, 0x6e, 0xd3, 0x24, 0x2e, 0x2b, 0x45, 0x8a, 0xe7, 0x00, 0x57, 0x57, 0xe7, 0x02, 0xf5,
	0x2a, 0x23, 0xcd, 0x76, 0xa1, 0x93, 0x2e, 0xc6, 0xed, 0xbd, 0xf6, 0x74, 0x28, 0x3a, 0xe9, 0x82,
	0xc5, 0x10, 0xe5, 0x92, 0x92, 0xaf, 0xea, 0xe6, 0x0e, 0x13, 0x1a, 0x77, 0xf6, 0xda, 0xd3, 0xe8,
	0xe4, 0xff, 0xf8, 0xca, 0x60, 0x9f, 0x2c, 0x26, 0x9a, 0x05, 0xec, 0x25, 0xf4, 0x2a, 0xa5, 0x09,
	0xab, 0x71, 0xd7, 0x96, 0xf6, 0x63, 0x61, 0x53, 0xe1, 0x61, 0xfe, 0x0e, 0xa2, 0x46, 0xf3, 0xd6,
	0xbc, 0x17, 0x00, 0x65, 0xa5, 0x4a, 0xac, 0x28, 0x45, 0x6d, 0xc7, 0x0d, 0x45, 0x03, 0xe1, 0x4b,
	0xe8, 0x39, 0xc2, 0xad, 0xce, 0x7d, 0xe8, 0x97, 0x99, 0x7c, 0xc0, 0xca, 0xb4, 0x75, 0xed, 0xe8,
	0xb9, 0xcd, 0x45, 0xc0, 0xd9, 0x01, 0xc0, 0x32, 0xcd, 0x08, 0xab, 0x6b, 0x8d, 0xe4, 0x05, 0x42,
	0x7c, 0x6e, 0xa1, 0xcf, 0x48, 0x62, 0xb8, 0x0c, 0x21, 0x7f, 0x03, 0x3d, 0x67, 0x09, 0x1b, 0x43,
	0x5f, 0xaf, 0x92, 0x04, 0xb5, 0xb6, 0xc3, 0x06, 0x22, 0xa4, 0xec, 0x29, 0xfc, 0x87, 0x55, 0xa5,
	0x2a, 0x2f, 0xd3, 0x25, 0x3c, 0x81, 0xfe, 0xbc, 0x52, 0xcb, 0x34, 0xc3, 0x7f, 0xfd, 0x39, 0x36,
	0x05, 0xaf, 0xe0, 0x8f, 0xf2, 0x34, 0x12, 0x1f, 0x42, 0x7f, 0x96, 0xcd, 0x8a, 0x72, 0x45, 0xfc,
	0x3d, 0x0c, 0xeb, 0x92, 0x5f, 0x99, 0xe2, 0x9b, 0x6a, 0x53, 0x5c, 0xb1, 0x08, 0x38, 0x27, 0xe8,
	0x39, 0x68, 0xab, 0xf9, 0x08, 0xa2, 0x60, 0x57, 0x89, 0x89, 0x3f, 0xfb, 0x28, 0x08, 0x2a, 0x31,
	0x11, 0xde, 0x4e, 0x13, 0x37, 0xab, 0x49, 0x06, 0xf9, 0x75, 0x35, 0x49, 0xaa, 0xab, 0x49, 0x12,
	0xbf, 0x04, 0x78, 0xe4, 0x31, 0x4e, 0x2e, 0x53, 0xcc, 0xc2, 0x70, 0x97, 0x30, 0x06, 0x3b, 0x79,
	0x5a, 0xac, 0xed, 0xe0, 0xae, 0xb0, 0xb1, 0xc5, 0xe4, 0xfd, 0xda, 0xd2, 0x1b, 0x4c, 0xde, 0xaf,
	0xf9, 0xdb, 0x9a, 0x8b, 0x24, 0x19, 0xae, 0x44, 0xad, 0x0a, 0xb2, 0x5c, 0x5d, 0xe1, 0x12, 0x73,
	0x8a, 0x98, 0xc9, 0x52, 0xe3, 0xc2, 0xd2, 0xb5, 0x45, 0x48, 0xf9, 0x29, 0x8c, 0x2e, 0xb5, 0x2a,
	0x7e, 0xef, 0x21, 0x83, 0x9d, 0x3b, 0xad, 0x0a, 0x7f, 0x5e, 0x36, 0xe6, 0xdf, 0xda, 0x00, 0x6e,
	0xbb, 0xe6, 0x4a, 0x65, 0x5b, 0x2d, 0xb5, 0x86, 0x4e, 0x53, 0xc3, 0xdf, 0xee, 0x06, 0x7b, 0x0d,
	0x4f, 0x0c, 0xfb, 0x75, 0x63, 0x49, 0x77, 0x6c, 0xe5, 0x6e, 0xbc, 0x21, 0x51, 0x8c, 0xee, 0x9a,
	0x29, 0x3f, 0x83, 0x9e, 0x13, 0xb3, 0x25, 0xe4, 0xe0, 0xa7, 0x8d, 0x33, 0x2b, 0x30, 0x8c, 0xe7,
	0x0e, 0x7a, 0xd8, 0xb8, 0x59, 0xaf, 0x60, 0x10, 0x70, 0xf3, 0xcb, 0x85, 0xcc, 0xd1, 0x13, 0xd9,
	0xd8, 0xfc, 0xd3, 0x5a, 0x66, 0x2b, 0x0c, 0xff, 0x64, 0x13, 0xfe, 0x1c, 0x86, 0x5f, 0xd2, 0x1c,
	0x35, 0xc9, 0xbc, 0x34, 0xd3, 0x49, 0x7b, 0xdf, 0x3b, 0xa4, 0x4f, 0xbe, 0x77, 0xa0, 0xfb, 0x61,
	0x3e, 0x63, 0x1c, 0xe0, 0x02, 0x29, 0xdc, 0x8a, 0x41, 0xec, 0xa3, 0x49, 0x1d, 0xf1, 0x16, 0x3b,
	0x84, 0xc8, 0xd5, 0x94, 0x4a, 0xcb, 0x8c, 0x6d, 0x3c, 0x31, 0x93, 0x8d, 0x8c, 0xb7, 0xd8, 0x14,
	0x76, 0xcf, 0x2a, 0x94, 0x84, 0x75, 0x7d, 0x14, 0x3f, 0x3e, 0x62, 0x93, 0x7e, 0xec, 0x22, 0xde,
	0x62, 0xfb, 0x10, 0x7d, 0x4c, 0x35, 0xcd, 0xfd, 0x0b, 0x10, 0xd6, 0x7f, 0x12, 0xbc, 0xe7, 0x2d,
	0x76, 0x0c, 0x23, 0x33, 0xb9, 0x71, 0x9a, 0x9b, 0x6e, 0x4f, 0xa2, 0xf8, 0xf1, 0x23, 0x6f, 0x1d,
	0xb7, 0xd9, 0x21, 0x30, 0x43, 0x3a, 0xbb, 0x2d, 0x54, 0x85, 0x8b, 0xc0, 0x0d, 0x71, 0xed, 0x44,
	0x93, 0xfe, 0x08, 0x9e, 0x5d, 0x20, 0x9d, 0xa9, 0xfc, 0x26, 0x2d, 0x70, 0xe1, 0x7a, 0x4c, 0x37,
	0x1b, 0xc4, 0xfe, 0x0a, 0x37, 0xaa, 0x6f, 0x7a, 0xf6, 0x51, 0x3e, 0xfd, 0x11, 0x00, 0x00, 0xff,
	0xff, 0x86, 0x78, 0x6e, 0xb4, 0xa5, 0x05, 0x00, 0x00,
}
